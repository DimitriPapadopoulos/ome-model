{% python
	def parent_object():
		if parents is None:
			return None
		return model.getObjectByName(parents.keys()[0])
	def is_abstract(name):
		o = model.getObjectByName(name)
		if o is None:
			return False
		return o.isAbstract
%}\
/*
 * ${fu.package}.${klass.name}
 *
 *-----------------------------------------------------------------------------
 *
 *  Copyright (C) @year@ Open Microscopy Environment
 *      Massachusetts Institute of Technology,
 *      National Institutes of Health,
 *      University of Dundee,
 *      University of Wisconsin-Madison
 *
 *
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *-----------------------------------------------------------------------------
 */

/*-----------------------------------------------------------------------------
 *
 * THIS IS AUTOMATICALLY GENERATED CODE.  DO NOT MODIFY.
 * Created by ${fu.user} via xsd-fu on ${fu.date}
 *
 *-----------------------------------------------------------------------------
 */

package ${fu.package};

import java.util.ArrayList;
import java.util.List;


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import ${fu.package}.enums.*;

{% choose %}\
{% when parent_object() is not None and parent_object().isAbstract %}\
public class ${klass.name} extends ${parent_object().name}
{% end %}\
{% when klass.isAbstract %}\
public abstract class ${klass.name} extends ${klass.javaBase}
{% end %}\
{% when parent_object() is None or not parent_object().isAbstract %}\
public class ${klass.name} extends ${klass.javaBase}
{% end %}\
{% end %}\
{
	// -- Constants --

	public static final String NAMESPACE = "${klass.namespace}";

	// -- Instance variables --
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.isReference or prop.name.endswith('Ref') %}
	// Back reference ${prop.name}
	private List<${prop.javaType}> ${prop.javaInstanceVariableName} = new ArrayList<${prop.javaType}>();
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstract or prop.isAttribute) %}
	// Property
	private ${prop.javaType} ${prop.javaInstanceVariableName};
{% end %}\
{% when prop.maxOccurs > 1 and not klass.isAbstract %}
	// Property which occurs more than once
	private List<${prop.javaType}> ${prop.javaInstanceVariableName} = new ArrayList<${prop.javaType}>();
{% end %}\
{% otherwise %}
	// *** WARNING *** Unhandled or skipped property ${prop.name}
{% end %}\
{% end %}\
{% end %}\

	// -- Constructors --

	/** Default constructor. */
	public ${klass.name}()
	{
		super();
	}

	/** 
	 * Constructs ${klass.name} recursively from an XML DOM tree.
	 * @param element Root of the XML DOM tree to construct a model object
	 * graph from.
	 * @throws EnumerationException If there is an error instantiating an
	 * enumeration during model object creation.
	 */
	public ${klass.name}(Element element) throws EnumerationException
	{
		update(element);
	}

	/** 
	 * Updates ${klass.name} recursively from an XML DOM tree. <b>NOTE:</b> No
	 * properties are removed, only added or updated.
	 * @param element Root of the XML DOM tree to construct a model object
	 * graph from.
	 * @throws EnumerationException If there is an error instantiating an
	 * enumeration during model object creation.
	 */
	public void update(Element element) throws EnumerationException
	{	
		super.update(element);
{% if not klass.isAbstract %}\
		String tagName = element.getTagName();
		if (!"${klass.name}".equals(tagName))
		{
			System.err.println(String.format(
					"WARNING: Expecting node name of ${klass.name} got %s",
					tagName));
			// TODO: Should be its own Exception
			//throw new RuntimeException(String.format(
			//		"Expecting node name of ${klass.name} got %s",
			//		tagName));
		}
{% end %}\
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.isReference or prop.name.endswith('Ref') %}\
		// *** IGNORING *** Skipped back reference ${prop.name}
{% end %}\
{% when prop.isAttribute %}\
		if (element.hasAttribute("${prop.name}"))
		{
{% if prop.isEnumeration %}\
			// Attribute property which is an enumeration ${prop.name}
			set${prop.javaMethodName}(${prop.javaType}.fromString(
					element.getAttribute("${prop.name}")));
{% end %}\
{% if not prop.isEnumeration %}\
			// Attribute property ${prop.name}
			set${prop.javaMethodName}(${prop.javaType}.valueOf(
					element.getAttribute("${prop.name}")));
{% end %}\
		}
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstract or prop.isComplex()) %}\
		NodeList ${prop.name}_nodeList = element.getElementsByTagName("${prop.name}");
		if (${prop.name}_nodeList.getLength() > 1)
		{
			// TODO: Should be its own Exception
			throw new RuntimeException(String.format(
					"${prop.name} node list size %d != 1",
					${prop.name}_nodeList.getLength()));
		}
		else if (${prop.name}_nodeList.getLength() != 0)
		{
{% if prop.isComplex() and not klass.isAbstract %}\
			// Element property ${prop.name} which is complex (has
			// sub-elements)
			set${prop.javaMethodName}(new ${prop.javaType}(
					(Element) ${prop.name}_nodeList.item(0)));
{% end %}\
{% if not prop.isComplex() %}\
			// Element property ${prop.name} which is not complex (has no
			// sub-elements)
			set${prop.javaMethodName}(${prop.name}_nodeList.item(0).getTextContent());
{% end %}\
		}
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() and not klass.isAbstract %}\
{% if is_abstract(prop.name) %}\
		// Element property ${prop.name} which is complex (has
		// sub-elements) and occurs more than once. The element's model
		// object type is also abstract so we need to have a handler for
		// each "subclass".
		NodeList ${prop.name}_nodeList = element.getElementsByTagName("${prop.name}");
		for (int i = 0; i < ${prop.name}_nodeList.getLength(); i++)
		{
			Element ${prop.name}_element = (Element) ${prop.name}_nodeList.item(i);
{% for inner_prop in model.getObjectByName(prop.name).properties.values() %}\
{% if not inner_prop.isAttribute and inner_prop.isComplex() and not inner_prop.name.endswith('Ref') %}\
			NodeList ${inner_prop.name}_nodeList = 
					${prop.name}_element.getElementsByTagName("${inner_prop.name}");
			for (int j = 0; j < ${inner_prop.name}_nodeList.getLength(); j++)
			{
				Element ${inner_prop.name}_element = (Element) ${inner_prop.name}_nodeList.item(j);
				${inner_prop.javaType} o = new ${inner_prop.javaType}(${inner_prop.name}_element);
				o.update(${prop.name}_element);
				add${prop.javaMethodName}(o);
			}
{% end %}\
{% end %}\
		}
{% end %}\
{% if not is_abstract(prop.name) %}\
		// Element property ${prop.name} which is complex (has
		// sub-elements) and occurs more than once
		NodeList ${prop.name}_nodeList = element.getElementsByTagName("${prop.name}");
		for (int i = 0; i < ${prop.name}_nodeList.getLength(); i++)
		{
			Element ${prop.name}_element = (Element) ${prop.name}_nodeList.item(i);
			add${prop.javaMethodName}(
					new ${prop.javaType}(${prop.name}_element));
		}
{% end %}\
{% end %}\
{% when prop.maxOccurs > 1 %}\
		// Element property ${prop.name} which is not complex (has no
		// sub-elements) which occurs more than once
		NodeList ${prop.name}_nodeList = element.getElementsByTagName("${prop.name}");
		for (int i = 0; i < ${prop.name}_nodeList.getLength(); i++)
		{
			add${prop.javaMethodName}(new ${prop.javaType}(
					${prop.name}_nodeList.item(i).getTextContent()));
		}
{% end %}\
{% otherwise %}\
		// *** WARNING *** Unhandled or skipped property ${prop.name}
{% end %}\
{% end %}\
{% end %}\
	}

	// -- ${klass.name} API methods --
{% for prop in klass.properties.values() %}\
{% choose %}\
{% when prop.name.endswith('Ref') %}
	// Reference ${prop.name}
	public int sizeOfLinked${prop.javaMethodName}List()
	{
		return ${prop.javaInstanceVariableName}.size();
	}

	public List<${prop.javaType}> copyLinked${prop.javaMethodName}List()
	{
		return new ArrayList<${prop.javaType}>(${prop.javaInstanceVariableName});
	}

	public ${prop.javaType} getLinked${prop.javaMethodName}(int index)
	{
		return ${prop.javaInstanceVariableName}.get(index);
	}

	public ${prop.javaType} setLinked${prop.javaMethodName}(int index, ${prop.javaType} o)
	{
		return ${prop.javaInstanceVariableName}.set(index, o);
	}

	public void link${prop.javaMethodName}(${prop.javaType} o)
	{
		this.${prop.javaInstanceVariableName}.add(o);
	}

	public void unlink${prop.javaMethodName}(${prop.javaType} o)
	{
		this.${prop.javaInstanceVariableName}.add(o);
	}
{% end %}\
{% when prop.maxOccurs == 1 and (not klass.isAbstract or prop.isAttribute) %}
	// Property
	public ${prop.javaType} get${prop.javaMethodName}()
	{
		return ${prop.javaArgumentName};
	}

	public void set${prop.javaMethodName}(${prop.javaType} ${prop.javaArgumentName})
	{
		this.${prop.javaInstanceVariableName} = ${prop.javaArgumentName};
	}
{% end %}\
{% when prop.maxOccurs > 1 and not klass.isAbstract %}
	// Property which occurs more than once
	public int sizeOf${prop.javaMethodName}List()
	{
		return ${prop.javaArgumentName}List.size();
	}

	public List<${prop.javaType}> copy${prop.javaMethodName}List()
	{
		return new ArrayList<${prop.javaType}>(${prop.javaInstanceVariableName});
	}

	public ${prop.javaType} get${prop.javaMethodName}(int index)
	{
		return ${prop.javaInstanceVariableName}.get(index);
	}

	public ${prop.javaType} set${prop.javaMethodName}(int index, ${prop.javaType} ${prop.javaArgumentName})
	{
		return ${prop.javaInstanceVariableName}.set(index, ${prop.javaArgumentName});
	}

	public void add${prop.javaMethodName}(${prop.javaType} ${prop.javaArgumentName})
	{
		${prop.javaInstanceVariableName}.add(${prop.javaArgumentName});
	}

	public void remove${prop.javaMethodName}(${prop.javaType} ${prop.javaArgumentName})
	{
		${prop.javaInstanceVariableName}.remove(${prop.javaArgumentName});
	}
{% end %}\
{% otherwise %}
	// *** WARNING *** Unhandled or skipped property ${prop.name}
{% end %}\
{% end %}\
{% end %}\

{% if not klass.isAbstract %}\
	public Element asXMLElement(Document document)
	{
		return asXMLElement(document, null);
	}

{% end %}\
	protected Element asXMLElement(Document document, Element ${klass.name}_element)
	{
		// Creating XML block for ${klass.name}
{% if klass.isAbstract %}\
		// Class is abstract so we may need to create its "container" element
		if (!"${klass.name}".equals(${klass.name}_element.getTagName()))
		{
			Element abstractElement =
					document.createElementNS("${klass.namespace}", "${klass.name}");
			abstractElement.appendChild(${klass.name}_element);
			${klass.name}_element = abstractElement;
		}
{% end %}\
		if (${klass.name}_element == null)
		{
			${klass.name}_element =
					document.createElementNS("${klass.namespace}", "${klass.name}");
		}

{% for prop in klass.properties.values() %}\
{% if not klass.isAbstract or prop.isAttribute %}\
		if (${prop.javaInstanceVariableName} != null)
		{
{% choose %}\
{% when prop.isReference or prop.name.endswith('Ref') %}\
			// *** IGNORING *** Skipped back reference ${prop.name}
{% end %}\
{% when prop.maxOccurs == 1 and prop.isAttribute %}\
			// Attribute property ${prop.name}
			${klass.name}_element.setAttribute("${prop.name}", ${prop.javaInstanceVariableName}.toString());
{% end %}\
{% when prop.maxOccurs == 1 and prop.isComplex() %}\
			// Element property ${prop.name} which is complex (has
			// sub-elements)
			${klass.name}_element.appendChild(${prop.javaInstanceVariableName}.asXMLElement(document));
{% end %}\
{% when prop.maxOccurs == 1 %}\
			// Element property ${prop.name} which is not complex (has no
			// sub-elements)
			Element ${prop.javaInstanceVariableName}_element = 
					document.createElementNS("${klass.namespace}", "${prop.name}");
			${prop.javaInstanceVariableName}_element.setTextContent(${prop.javaInstanceVariableName});
			${klass.name}_element.appendChild(${prop.javaInstanceVariableName}_element);
{% end %}\
{% when prop.maxOccurs > 1 and prop.isComplex() %}\
			// Element property ${prop.name} which is complex (has
			// sub-elements) and occurs more than once
			for (${prop.javaType} ${prop.javaInstanceVariableName}_value : ${prop.javaInstanceVariableName})
			{
				${klass.name}_element.appendChild(${prop.javaInstanceVariableName}_value.asXMLElement(document));
			}
{% end %}\
{% when prop.maxOccurs > 1 %}\
			// Element property ${prop.name} which is not complex (has no
			// sub-elements) which occurs more than once
			for (${prop.javaType} ${prop.javaInstanceVariableName}_value : ${prop.javaInstanceVariableName})
			{
				Element ${prop.javaInstanceVariableName}_element =
						document.createElementNS("${klass.namespace}", "${prop.name}");
				${prop.javaInstanceVariableName}_element.setTextContent(${prop.javaInstanceVariableName}_value);
				${klass.name}_element.appendChild(${prop.javaInstanceVariableName}_element);
			}
{% end %}\
{% otherwise %}\
			// *** WARNING *** Unhandled or skipped property ${prop.name}
{% end %}\
{% end %}\
		}
{% end %}\
{% end %}\
		return super.asXMLElement(document, ${klass.name}_element);
	}
}
