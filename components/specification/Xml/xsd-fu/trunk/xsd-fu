#!/usr/bin/env python
# encoding: utf-8
"""
Generate Java classes from an OME XML (http://www.ome-xml.org) XSD document.
"""

#  
#  Copyright (c) 2007 Chris Allan
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.

import logging
import sys
import os

from fu import *

from genshi.template import NewTextTemplate
from getopt import getopt, GetoptError
from xml import sax

def baseUsage():
	"""
	Prints usage so that we don't have to. :)
	"""
	cmd = sys.argv[0]
	print """Usage: %s <subcommand> ...
Executes an OME-XML Schema definition parsing and code generation task.

Available subcommands:
  java_classes
  metadata_store
  metadata_retrieve
  doc_gen
  tab_gen
  debug

Report bugs to OME Devel <ome-devel@lists.openmicroscopy.org.uk>""" % \
	(cmd)
	sys.exit(2)

def usage(error):
	"""
	Prints usage so that we don't have to. :)
	"""
	cmd = sys.argv[0]
	print """%s
Usage: %s [-n xsd_namespace] [-p package] -o <output_dir> <path/to/ome.xsd>
Generates Java classes from an OME XML Schema definition.

Default package: "%s"
Default namespace: "%s"

Examples:
  %s -n 'xs:' -p ome.xml -o ome/xml schemas/ome.xsd

Report bugs to OME Devel <ome-devel@lists.openmicroscopy.org.uk>""" % \
	(error, cmd, DEFAULT_PACKAGE, DEFAULT_NAMESPACE, cmd)
	sys.exit(2)

def main():
	"""
	Default main() that parses command line options and generates Java 
	classes in the output directory.
	"""
	try:
		options, args = getopt(sys.argv[1:], "o:p:n:")
	except GetoptError, (msg, opt):
		usage(msg)

	if len(args) != 1:
		usage("Expecting single ome.xsd file path!")

	outputDirectory = None
	package = DEFAULT_PACKAGE
	namespace = DEFAULT_NAMESPACE
	for option, argument in options:
		if option == "-o":
			outputDirectory = argument
		if option == "-p":
			package = argument
		if option == "-n":
			namespace = argument
	if outputDirectory is None:
		usage("Output directory must be specified!")
	if not os.path.exists(outputDirectory):
		print "Output directory '%s' does not exist!" % outputDirectory
		sys.exit(1)

	model = parseXmlSchema([args[0]], namespace)
	fu = TemplateInfo(outputDirectory, package)
	template = NewTextTemplate(open(CLASS_TEMPLATE).read())
	for obj in model.objects.values():
		f = open(os.path.join(outputDirectory, "%sNode.java" % obj.name), "w")
		classContent = template.generate(fu=fu, klass=obj).render()
		f.write(classContent)
		f.close()

def index_string(name):
	"""Makes a Java method signature string from an index name."""
	if name[:2].isupper():
		return "int %sIndex" % name
	else:
		return "int %s%sIndex" % (name[:1].lower(), name[1:])

def max_occurs_under_parent(model, parent, name):
	"""
	Returns the maximum occurrances of a given object under its current
	parent.
	"""
	parent = model.getObjectByName(parent)
	for prop in parent.properties.values():
		if prop.name == name:
			return prop.maxOccurs
	

def resolve_indexes(indexes, model, names):
	"""
	Resolves a String index representation of the hierarchical structure of
	element names. Updates indexes list and returns a boolean True if the
	indexes are multi-path, a boolean False otherwise.
	"""
	is_multi_path = False
	if names is None:
		return is_multi_path
	for name in names.keys():
		if name == 'OME':
			# Ignore the OME tag
			return is_multi_path
		if len(names.keys()) > 1:
			is_multi_path = True
		# We only want to add the index if the object count at this level
		# is greater than 1.
		if names[name] is not None:
			# We have a parent, use the first even if we're multi-path
			parent = names[name].keys()[0]
			if max_occurs_under_parent(model, parent, name) > 1:
				indexes.append(index_string(name))
		else:
			# We don't have a parent, insert the index anyway
			indexes.append(index_string(name))
		is_child_multi_path = resolve_indexes(indexes, model, names[name])
		if is_child_multi_path:
			is_multi_path = True
	return is_multi_path

def metadataStoreMain(args):
	"""
	Default main() that parses command line options and generates a
	MetadataStore implementation.
	"""
	try:
		options, args = getopt(args, "n:")
	except GetoptError, (msg, opt):
		usage(msg)

	if len(args) < 1:
		usage("Expecting at least one ome.xsd file path!")

	namespace = DEFAULT_NAMESPACE
	for option, argument in options:
		if option == "-n":
			namespace = argument

	model = parseXmlSchema(args, namespace)
	indexes = dict()
	parents = dict()
	is_multi_path = dict()
	for obj in model.objects.values():
		name = obj.name
		indexes[name] = list()
		parents[name] = resolve_parents(model, name)
		is_multi_path[name] = resolve_indexes(indexes[name], model, parents[name])
		indexes[name].reverse()
		if parents[name] is not None:
			# We have a parent, use the first even if we're multi-path
			parent = parents[name].keys()[0]
			if max_occurs_under_parent(model, parent, name) > 1:
				indexes[name].append(index_string(name))
		indexes[name] = ", ".join(indexes[name])
		parents[name] = "%r" % parents[name]
	fu = TemplateInfo(None, None)
	template = NewTextTemplate(open(METADATA_STORE_TEMPLATE).read())
	sorted_objects = model.objects.values()
	sorted_objects.sort(lambda x, y: cmp(x.name, y.name))
	content = template.generate(fu=fu, model=model, parents=parents,
								is_multi_path=is_multi_path,
								sorted_objects=sorted_objects,
			                    indexes=indexes).render()
	f = open("MetadataStore.java", "w")
	f.write(content)
	f.close()
	
def metadataRetrieveMain(args):
	"""
	Default main() that parses command line options and generates a
	MetadataRetrieve implementation.
	"""
	try:
		options, args = getopt(args, "n:")
	except GetoptError, (msg, opt):
		usage(msg)

	if len(args) < 1:
		usage("Expecting at least one ome.xsd file path!")

	namespace = DEFAULT_NAMESPACE
	for option, argument in options:
		if option == "-n":
			namespace = argument

	model = parseXmlSchema(args, namespace)
	indexes = dict()
	parents = dict()
	is_multi_path = dict()
	for obj in model.objects.values():
		name = obj.name
		indexes[name] = list()
		parents[name] = resolve_parents(model, name)
		is_multi_path[name] = resolve_indexes(indexes[name], model, parents[name])
		parents[name] = "%r" % parents[name]
		indexes[name].reverse()
		indexes[name].append(index_string(name))
		indexes[name] = ", ".join(indexes[name])
	fu = TemplateInfo(None, None)
	template = NewTextTemplate(open(METADATA_RETRIEVE_TEMPLATE).read())
	sorted_objects = model.objects.values()
	sorted_objects.sort(lambda x, y: cmp(x.name, y.name))
	content = template.generate(fu=fu, model=model, parents=parents,
								is_multi_path=is_multi_path,
								sorted_objects=sorted_objects,
			                    indexes=indexes).render()
	f = open("MetadataRetrieve.java", "w")
	f.write(content)
	f.close()

def debugMain():
	"""
	Debugging main() that does not parse the command line and spits
	generated data to STDOUT.
	"""
	outputDirectory = None
	package = DEFAULT_PACKAGE
	namespace = "xsd:"

	model = parseXmlSchema(["../../Working/ome.xsd"], namespace)
	fu = TemplateInfo(outputDirectory, package)
	template = NewTextTemplate(open(CLASS_TEMPLATE).read())
	for obj in model.objects.values():
		if obj.name in ["Detector"]:
			print " +-- %s(base=%s, type=%s)" % (obj.name, obj.base, obj.type)
			for prop in obj.properties.values():
				print " +---- %s(%s) [%d:%d]" % \
				    (prop.name, prop.type, prop.minOccurs, prop.maxOccurs)
			print "\n"
			print template.generate(fu=fu, klass=obj).render()

def docGenMain():
	"""
	Documentation main() that does not parse the command line and spits
	generated wiki formatted docs to STDOUT.
	Added by Andrew Patterson (July 2008) to generate content for 
	the ArityOfSchema page on http://ome-xml.org
	"""
	outputDirectory = None
	package = DEFAULT_PACKAGE
	namespace = "xsd:"
	
	for theSchemas in [
	["OME","../../Working/ome.xsd"], 
	["SPW","../../Working/SPW.xsd"],
	["CA","../../Working/CA.xsd"],
	["CLI","../../Working/CLI.xsd"],
	["AnalysisChain","../../Working/AnalysisChain.xsd"],
	["AnalysisModule","../../Working/AnalysisModule.xsd"],
	["BinaryFile","../../Working/BinaryFile.xsd"],
	["DataHistory","../../Working/DataHistory.xsd"],
	["MLI","../../Working/MLI.xsd"],
	["SA","../../Working/SA.xsd"],
	["STD","../../Working/STD.xsd"]
	]:
		prefix = theSchemas[0] + ":"
		model = parseXmlSchema([theSchemas[1]], namespace)
		fu = TemplateInfo(outputDirectory, package)
		template = NewTextTemplate(open(CLASS_TEMPLATE).read())
		print " == `%s` ==" % (prefix)
		for obj in model.objects.values():
			print " === %s%s ===" % (prefix, obj.name)
			print " * %s%s(base = `%s`, type = `%s`)" % (prefix, obj.name, obj.base, obj.type)
			for prop in obj.properties.values():
				print "   * %s%s:%s( `%s` ) ![%d:%d]" % \
				    (prefix, obj.name, prop.name, prop.type, prop.minOccurs, prop.maxOccurs)
			print "\n"

def tabGenMain():
	"""
	Documentation main() that does not parse the command line and puts
	tab sperated format to STDOUT.
	Added by Andrew Patterson (October 2008) to generate content for arity spreadsheet
	"""
	outputDirectory = None
	package = DEFAULT_PACKAGE
	namespace = "xsd:"
	
	for theSchemas in [
	["OME","../../Working/ome.xsd", [["OME", "OME:"]]], 
	["SPW","../../Working/SPW.xsd", [["Plate", "OME:Plate:"],["Screen", "OME:Screen:"]]],
	["CA","../../Working/CA.xsd", [["CustomAttributes", "OME:Image:CustomAttributes:"],["CustomAttributes", "OME:CustomAttributes:"],["CustomAttributes", "OME:Region:CustomAttributes:"]]],
	["SA","../../Working/SA.xsd", [["StructuredAnnotations", "OME:StructuredAnnotations:"]]],
	["STD","../../Working/STD.xsd", [["SemanticTypeDefinitions", "OME:SemanticTypeDefinitions:"]]],
	["AnalysisModule","../../Working/AnalysisModule.xsd", [["AnalysisModuleLibrary", "OME:AnalysisModuleLibrary:"]]],
	["BinaryFile","../../Working/BinaryFile.xsd", [["BinaryFile", "OME:Instrument:OTF:BinaryFile:"]]]#,

	#["CLI","../../Working/CLI.xsd"],
	#["AnalysisChain","../../Working/AnalysisChain.xsd"],
	#["DataHistory","../../Working/DataHistory.xsd"],
	#["MLI","../../Working/MLI.xsd"],
	]:
		prefix = theSchemas[0] + ":"
		model = parseXmlSchema([theSchemas[1]], namespace)
		fu = TemplateInfo(outputDirectory, package)
		template = NewTextTemplate(open(CLASS_TEMPLATE).read())
		for theToplevelNode in theSchemas[2]:
			parentlist(model, theToplevelNode[0], theToplevelNode[1])

def parentlist(model, name, pre):
	for obj in model.objects.values():
		if obj.name in [name]:
			#print pre + name;
			for prop in obj.properties.values():
				if prop.name[-14:] == "_BackReference":
					print "%s\t%s" % (prop.minOccurs, prop.maxOccurs ) + "\t" + prop.name + "\t" + prop.type + "\tback\t" + pre + prop.name;
					pass
				else:
					if prop.name == name:
						print "%s\t%s" % (prop.minOccurs, prop.maxOccurs ) + "\t" + prop.name + "\t" + prop.type + "\trecursion\t" + pre + prop.name + " - recursion";
					else:
						print "%s\t%s" % (prop.minOccurs, prop.maxOccurs ) + "\t" + prop.name + "\t" + prop.type + "\t\t" + pre + prop.name;
						parentlist(model, prop.type, pre + prop.name + ":")

if __name__ == '__main__':
	if len(sys.argv) == 1:
		baseUsage()
	#  java_classes
	#  metadata_store
	#  metadata_retrieve
	#  doc_gen
	#  tab_gen
	#  debug
	a = sys.argv[1]
	if a == "java_classes":
		main(sys.argv[2:])
	if a == "metadata_store":
		metadataStoreMain(sys.argv[2:])
	if a == "metadata_retrieve":
		metadataRetrieveMain(sys.argv[2:])
	if a == "debug":
		debugMain(sys.argv[2:])
#	debugMain()
#	docGenMain()
#	tabGenMain()
#	metadataStoreMain()
#	main()

